/*
 * Copyright 2024 Tom Clabault. GNU GPL3 license.
 * GNU GPL3 license copy: https://www.gnu.org/licenses/gpl-3.0.txt
 */

#ifndef DEVICE_RESTIR_DI_DECOUPLED_SHADING_H
#define DEVICE_RESTIR_DI_DECOUPLED_SHADING_H

#include "Device/includes/Dispatcher.h"
#include "Device/includes/FixIntellisense.h"
#include "Device/includes/Hash.h"
#include "Device/includes/Intersect.h"
#include "Device/includes/LightUtils.h"
#include "Device/includes/ReSTIR/Jacobian.h"
#include "Device/includes/ReSTIR/NeighborSimilarity.h"
#include "Device/includes/ReSTIR/OptimalVisibilitySampling.h"
#include "Device/includes/ReSTIR/SpatialMISWeight.h"
#include "Device/includes/ReSTIR/SpatialNormalizationWeight.h"
#include "Device/includes/ReSTIR/Surface.h"
#include "Device/includes/ReSTIR/Utils.h"
#include "Device/includes/ReSTIR/UtilsSpatial.h"
#include "Device/includes/ReSTIR/DI/TargetFunction.h"
#include "Device/includes/Sampling.h"

#include "HostDeviceCommon/HIPRTCamera.h"
#include "HostDeviceCommon/Color.h"
#include "HostDeviceCommon/HitInfo.h"
#include "HostDeviceCommon/RenderData.h"

  /** References:
  *
  * [1] [Spatiotemporal reservoir resampling for real-time ray tracing with dynamic direct lighting] https://research.nvidia.com/labs/rtr/publication/bitterli2020spatiotemporal/
  * [2] [A Gentle Introduction to ReSTIR: Path Reuse in Real-time] https://intro-to-restir.cwyman.org/
  * [3] [A Gentle Introduction to ReSTIR: Path Reuse in Real-time - SIGGRAPH 2023 Presentation Video] https://dl.acm.org/doi/10.1145/3587423.3595511#sec-supp
  * [4] [NVIDIA RTX DI SDK - Github] https://github.com/NVIDIAGameWorks/RTXDI
  * [5] [Generalized Resampled Importance Sampling Foundations of ReSTIR] https://research.nvidia.com/publication/2022-07_generalized-resampled-importance-sampling-foundations-restir
  * [6] [Uniform disk sampling] https://rh8liuqy.github.io/Uniform_Disk.html
  * [7] [Reddit Post for the Jacobian term needed] https://www.reddit.com/r/GraphicsProgramming/comments/1eo5hqr/restir_di_light_sample_pdf_confusion/
  * [8] [Rearchitecting Spatiotemporal Resampling for Production] https://research.nvidia.com/publication/2021-07_rearchitecting-spatiotemporal-resampling-production
  */

#ifdef __KERNELCC__
GLOBAL_KERNEL_SIGNATURE(void) __launch_bounds__(64) ReSTIR_DI_DecoupledShading(HIPRTRenderData render_data)
#else
GLOBAL_KERNEL_SIGNATURE(void) inline ReSTIR_DI_DecoupledShading(HIPRTRenderData render_data, int x, int y)
#endif
{
#ifdef __KERNELCC__
	const uint32_t x = blockIdx.x * blockDim.x + threadIdx.x;
	const uint32_t y = blockIdx.y * blockDim.y + threadIdx.y;
#endif
	if (x >= render_data.render_settings.render_resolution.x || y >= render_data.render_settings.render_resolution.y)
		return;

	uint32_t center_pixel_index = (x + y * render_data.render_settings.render_resolution.x);

	if (!render_data.aux_buffers.pixel_active[center_pixel_index] || render_data.g_buffer.first_hit_prim_index[center_pixel_index] == -1)
		// Pixel inactive because of adaptive sampling, returning
		// Or also we don't have a primary hit
		return;

	// Initializing the random generator
	// TODO try having multiply instead of XOR again
	unsigned int seed = render_data.render_settings.freeze_random ? wang_hash(center_pixel_index + 1) : wang_hash(((center_pixel_index + 1) * (render_data.render_settings.sample_number + 1)) ^ render_data.random_number);
	Xorshift32Generator random_number_generator(seed);

	ReSTIRDIReservoir* input_reservoir_buffer = render_data.render_settings.restir_di_settings.restir_output_reservoirs;

	int2 center_pixel_coords = make_int2(x, y);

	// Rotation that is going to be used to rotate the points generated by the Hammersley sampler
	// for generating the neighbors location to resample
	float rotation_theta;
	if (render_data.render_settings.restir_di_settings.common_spatial_pass.do_neighbor_rotation && render_data.render_settings.restir_di_settings.common_spatial_pass.use_hammersley)
		rotation_theta = M_TWO_PI * random_number_generator();
	else
		rotation_theta = 0.0f;
	float2 cos_sin_theta_rotation = make_float2(cos(rotation_theta), sin(rotation_theta));

	ReSTIRDIReservoir center_pixel_reservoir = input_reservoir_buffer[center_pixel_index];
	if ((center_pixel_reservoir.M <= 1) && render_data.render_settings.restir_di_settings.common_spatial_pass.do_disocclusion_reuse_boost)
		// Increasing the number of spatial samples for disocclusions
		render_data.render_settings.restir_di_settings.common_spatial_pass.reuse_neighbor_count = render_data.render_settings.restir_di_settings.common_spatial_pass.disocclusion_reuse_count;

	ReSTIRSurface center_pixel_surface = get_pixel_surface(render_data, center_pixel_index, random_number_generator);

	setup_adaptive_directional_spatial_reuse<false>(render_data, center_pixel_index, cos_sin_theta_rotation, random_number_generator);

	// Only used with MIS-like weight
	int selected_neighbor = 0;
	int neighbor_heuristics_cache = 0;
	int valid_neighbors_count = 0;
	int valid_neighbors_M_sum = 0;
	count_valid_spatial_neighbors<false>(render_data,
		center_pixel_surface, input_reservoir_buffer,
		center_pixel_coords, cos_sin_theta_rotation, 
		valid_neighbors_count, valid_neighbors_M_sum, neighbor_heuristics_cache);

	ReSTIRSpatialResamplingMISWeight<ReSTIR_DI_BiasCorrectionWeights, /* IsReSTIRGI */ false> mis_weight_function;
	Xorshift32Generator spatial_neighbors_rng(render_data.render_settings.restir_di_settings.common_spatial_pass.spatial_neighbors_rng_seed);
	ColorRGB32F decoupled_shading_reuse_result;

	// Resampling the neighbors. Using neighbors + 1 here so that
	// we can use the last iteration of the loop to resample ourselves (the center pixel)
	// 
	// See the implementation of get_spatial_neighbor_pixel_index() in ReSTIR/DI/Utils.h
	int reused_neighbors_count = render_data.render_settings.restir_di_settings.common_spatial_pass.reuse_neighbor_count;
	int start_index = 0;
	if (valid_neighbors_M_sum == 0)
		// No valid neighbor to resample from, skip to the initial candidate right away
		start_index = reused_neighbors_count;
	for (int neighbor_index = start_index; neighbor_index < reused_neighbors_count + 1; neighbor_index++)
	{
		// We can already check whether or not this neighbor is going to be
		// accepted at all by checking the heuristic cache
		if (neighbor_index < reused_neighbors_count && reused_neighbors_count <= 32)
		{
			// If not the center pixel, we can check the heuristics, otherwise there's no need to,
			// we know that the center pixel will be accepted
			// 
			// Our heuristics cache is a 32bit int so we can only cache 32 values are we're
			// going to have issues if we try to read more than that.
			if ((neighbor_heuristics_cache & (1 << neighbor_index)) == 0)
			{
				// Advancing the rng for generating the spatial neighbors since if we "continue" here, the spatial neighbors rng
				// isn't going to be advanced by the call to 'get_spatial_neighbor_pixel_index' below so we're doing it manually
				spatial_neighbor_advance_rng<false>(render_data, spatial_neighbors_rng);

				// Neighbor not passing the heuristics tests, skipping it right away
				continue;
			}
		}

		int neighbor_pixel_index = get_spatial_neighbor_pixel_index<false>(render_data, neighbor_index, center_pixel_coords, cos_sin_theta_rotation, spatial_neighbors_rng);
		if (neighbor_pixel_index == -1)
			// Neighbor out of the viewport
			continue;

		if (neighbor_index < reused_neighbors_count && reused_neighbors_count > 32)
			// If not the center pixel, we can check the heuristics
			// 
			// Only checking the heuristic if we have more than 32 neighbors (does not fit in the heuristic cache)
			// If we have less than 32 neighbors, we've already checked the cache at the beginning of this for loop
			if (!check_neighbor_similarity_heuristics<false>(render_data,
				neighbor_pixel_index, center_pixel_index, center_pixel_surface.shading_point, ReSTIRSettingsHelper::get_normal_for_rejection_heuristic<false>(render_data, center_pixel_surface)))
				continue;

		ReSTIRDIReservoir neighbor_reservoir = input_reservoir_buffer[neighbor_pixel_index];

		float target_function_at_center = 0.0f;
		if (neighbor_reservoir.UCW > 0.0f)
		{
			if (neighbor_index == reused_neighbors_count)
				// No need to evaluate the center sample at the center pixel, that's exactly
				// the target function of the center reservoir
				target_function_at_center = neighbor_reservoir.sample.target_function;
			else
				target_function_at_center = ReSTIR_DI_evaluate_target_function<false>(render_data, neighbor_reservoir.sample, center_pixel_surface, random_number_generator);
		}

#if ReSTIR_DI_BiasCorrectionWeights == RESTIR_DI_BIAS_CORRECTION_1_OVER_M
		float mis_weight = mis_weight_function.get_resampling_MIS_weight(neighbor_reservoir.M);
#elif ReSTIR_DI_BiasCorrectionWeights == RESTIR_DI_BIAS_CORRECTION_1_OVER_Z
		float mis_weight = mis_weight_function.get_resampling_MIS_weight(neighbor_reservoir.M);
#elif ReSTIR_DI_BiasCorrectionWeights == RESTIR_DI_BIAS_CORRECTION_MIS_LIKE
		float mis_weight = mis_weight_function.get_resampling_MIS_weight(render_data, neighbor_reservoir.M);
#elif ReSTIR_DI_BiasCorrectionWeights == RESTIR_DI_BIAS_CORRECTION_MIS_GBH
		float mis_weight = mis_weight_function.get_resampling_MIS_weight(render_data,

			neighbor_reservoir.UCW,
			neighbor_reservoir.sample,

			center_pixel_surface, neighbor_index, center_pixel_coords, cos_sin_theta_rotation, random_number_generator);
#elif ReSTIR_DI_BiasCorrectionWeights == RESTIR_DI_BIAS_CORRECTION_PAIRWISE_MIS || ReSTIR_DI_BiasCorrectionWeights == RESTIR_DI_BIAS_CORRECTION_PAIRWISE_MIS_DEFENSIVE
		bool update_mc = center_pixel_reservoir.M > 0 && center_pixel_reservoir.UCW > 0.0f;

		float mis_weight = mis_weight_function.get_resampling_MIS_weight(render_data,

			neighbor_reservoir.M, neighbor_reservoir.sample.target_function,
			center_pixel_reservoir.sample, center_pixel_reservoir.M, center_pixel_reservoir.sample.target_function,
			neighbor_reservoir,

			center_pixel_surface, target_function_at_center, neighbor_pixel_index, valid_neighbors_count, valid_neighbors_M_sum,
			update_mc,/* resampling canonical */ neighbor_index == reused_neighbors_count, random_number_generator);
#elif ReSTIR_DI_BiasCorrectionWeights == RESTIR_DI_BIAS_CORRECTION_SYMMETRIC_RATIO || ReSTIR_DI_BiasCorrectionWeights == RESTIR_DI_BIAS_CORRECTION_ASYMMETRIC_RATIO
		bool update_mc = center_pixel_reservoir.M > 0 && center_pixel_reservoir.UCW > 0.0f;

		float mis_weight = mis_weight_function.get_resampling_MIS_weight(render_data,

			neighbor_reservoir.M, neighbor_reservoir.sample.target_function,
			center_pixel_reservoir.sample, center_pixel_reservoir.M, center_pixel_reservoir.sample.target_function,
			neighbor_reservoir,

			center_pixel_surface, target_function_at_center, neighbor_pixel_index, valid_neighbors_count, valid_neighbors_M_sum,
			update_mc,/* resampling canonical */ neighbor_index == reused_neighbors_count, random_number_generator);
#else
#error "Unsupported bias correction mode"
#endif

		if (mis_weight > 0.0f && target_function_at_center > 0.0f)
		{
			neighbor_reservoir.sample.flags &= ~ReSTIRDISampleFlags::RESTIR_DI_FLAGS_UNOCCLUDED;
			decoupled_shading_reuse_result += shade_ReSTIR_DI_reservoir(render_data, center_pixel_surface.ray_volume_state, center_pixel_surface.material, center_pixel_surface.last_hit_primitive_index,
				center_pixel_surface.shading_point, center_pixel_surface.view_direction, center_pixel_surface.shading_normal, center_pixel_surface.geometric_normal,
				neighbor_reservoir, random_number_generator) * mis_weight;
		}
	}

	render_data.render_settings.restir_di_settings.common_spatial_pass.decoupled_shading_reuse_buffer[center_pixel_index] = decoupled_shading_reuse_result;
}

#endif
