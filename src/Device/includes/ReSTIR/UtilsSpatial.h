/*
 * Copyright 2024 Tom Clabault. GNU GPL3 license.
 * GNU GPL3 license copy: https://www.gnu.org/licenses/gpl-3.0.txt
 */

#ifndef DEVICE_RESTIR_UTILS_SPATIAL_H
#define DEVICE_RESTIR_UTILS_SPATIAL_H

#include "HostDeviceCommon/KernelOptions/ReSTIRGIOptions.h"

#include "HostDeviceCommon/RenderData.h"

template <bool IsReSTIRGI>
HIPRT_HOST_DEVICE HIPRT_INLINE bool do_include_visibility_term_or_not(const HIPRTRenderData& render_data, int current_neighbor_index)
{
	const ReSTIRCommonSpatialPassSettings& spatial_settings = ReSTIRSettingsHelper::get_restir_spatial_pass_settings<IsReSTIRGI>(render_data);
	bool visibility_only_on_last_pass = spatial_settings.do_visibility_only_last_pass;
	bool is_last_pass = spatial_settings.spatial_pass_index == spatial_settings.number_of_passes - 1;

	// Only using the visibility term on the last pass if so desired
	bool include_target_function_visibility = visibility_only_on_last_pass && is_last_pass;
	// Also allowing visibility if we want it at every pass
	include_target_function_visibility |= !spatial_settings.do_visibility_only_last_pass;

	// Only doing visibility for a few neighbors depending on 'neighbor_visibility_count'
	include_target_function_visibility &= current_neighbor_index < spatial_settings.neighbor_visibility_count;

	// Only doing visibility if we want it at all
	include_target_function_visibility &= IsReSTIRGI ? ReSTIR_GI_SpatialTargetFunctionVisibility : ReSTIR_DI_SpatialTargetFunctionVisibility;

	// We don't want visibility for the center pixel because we're going to reuse the
	// target function stored in the reservoir anyways
	// Note: the center pixel has index 'spatial_settings.reuse_neighbor_count'
	// while actual *neighbors* have index between [0, spatial_settings.reuse_neighbor_count - 1]
	include_target_function_visibility &= current_neighbor_index != spatial_settings.reuse_neighbor_count;

	return include_target_function_visibility;
}

/**
 * Returns the linear index that can be used directly to index a buffer
 * of render_data of the 'neighbor_number'th neighbor that we're going
 * to spatially reuse from
 *
 * 'neighbor_number' is in [0, neighbor_reuse_count]
 * 'neighbor_reuse_count' is in [1, ReSTIR_DI_Settings.reuse_neighbor_count]
 * 'neighbor_reuse_radius' is the radius of the disk within which the neighbors are sampled
 * 'center_pixel_coords' is the coordinates of the center pixel that is currently
 *		doing the resampling of its neighbors. Neighbors will be spatially sampled
 *		around that position
 * 'res' is the resolution of the viewport. This is used to check whether the generated
 *		neighbor location is outside of the viewport or not
 * 'cos_sin_theta_rotation' is a pair of float [x, y] with x = cos(random_rotation) and
 *		y = sin(random_rotation). This is used to rotate the points generated by the Hammersley
 *		sampler so that not each pixel on the image resample the exact same neighbors (and so
 *		that a given pixel P resamples different neighbors accros different frame, otherwise
 *		the Hammersley sampler would always generate the exact same points
 * 'rng_converged_neighbor_reuse' is a random generator used specifically for generating
 *		random numbers to test against the 'restir_di_settings.spatial_pass.converged_neighbor_reuse_probability'
 *		if the user has allowed reusing converged neighbors (when adaptive sampling is used).
 *		The same random number generator with the same seed must be given to *all* get_spatial_neighbor_pixel_index()
 *		calls of this thread invocation
 */
template <bool IsReSTIRGI>
HIPRT_HOST_DEVICE HIPRT_INLINE int get_spatial_neighbor_pixel_index(const HIPRTRenderData& render_data,
	int neighbor_index,
	int2 center_pixel_coords, float2 cos_sin_theta_rotation, Xorshift32Generator rng_converged_neighbor_reuse)
{
	const ReSTIRCommonSpatialPassSettings& spatial_pass_settings = ReSTIRSettingsHelper::get_restir_spatial_pass_settings<IsReSTIRGI>(render_data);

	int neighbor_pixel_index;
	if (neighbor_index == spatial_pass_settings.reuse_neighbor_count)
	{
		// If this is the last neighbor, we set it to ourselves
		// This is why our loop on the neighbors goes up to 'i < NEIGHBOR_REUSE_COUNT + 1'
		// It's so that when i == NEIGHBOR_REUSE_COUNT, we resample ourselves
		neighbor_pixel_index = center_pixel_coords.x + center_pixel_coords.y * render_data.render_settings.render_resolution.x;
	}
	else
	{
		// +1 and +1 here because we want to skip the first point as it is always (0, 0)
		// which means that we would be resampling ourselves (the center pixel) --> 
		// pointless because we already resample ourselves "manually" (that's why there's that
		// "if (neighbor_index == neighbor_reuse_count)" above, to resample the center pixel)
		float2 uv = sample_hammersley_2D(spatial_pass_settings.reuse_neighbor_count + 1, neighbor_index + 1);
		float2 neighbor_offset_in_disk = sample_in_disk_uv(spatial_pass_settings.reuse_radius, uv);

		// 2D rotation matrix: https://en.wikipedia.org/wiki/Rotation_matrix
		float cos_theta = cos_sin_theta_rotation.x;
		float sin_theta = cos_sin_theta_rotation.y;
		float2 neighbor_offset_rotated = make_float2(neighbor_offset_in_disk.x * cos_theta - neighbor_offset_in_disk.y * sin_theta, neighbor_offset_in_disk.x * sin_theta + neighbor_offset_in_disk.y * cos_theta);
		int2 neighbor_offset_int = make_int2(static_cast<int>(neighbor_offset_rotated.x), static_cast<int>(neighbor_offset_rotated.y));

		int2 neighbor_pixel_coords;
		if (spatial_pass_settings.debug_neighbor_location)
		{
			if (spatial_pass_settings.debug_neighbor_location_direction == 0)
				// Horizontal
				neighbor_pixel_coords = center_pixel_coords + make_int2(spatial_pass_settings.reuse_radius, 0);
			else if (spatial_pass_settings.debug_neighbor_location_direction == 1)
				// Vertical
				neighbor_pixel_coords = center_pixel_coords + make_int2(0, spatial_pass_settings.reuse_radius);
			else
				// Diagonal (and default case)
				neighbor_pixel_coords = center_pixel_coords + make_int2(spatial_pass_settings.reuse_radius, spatial_pass_settings.reuse_radius);
		}
		else
			neighbor_pixel_coords = center_pixel_coords + neighbor_offset_int;

		int2 DEBUG_DIRECTION = neighbor_pixel_coords - center_pixel_coords;
#ifndef __KERNELCC__
		std::cout << "neighbor direction: " << DEBUG_DIRECTION.x << ", " << DEBUG_DIRECTION.y << std::endl;
#endif

		if (neighbor_pixel_coords.x < 0 || neighbor_pixel_coords.x >= render_data.render_settings.render_resolution.x || neighbor_pixel_coords.y < 0 || neighbor_pixel_coords.y >= render_data.render_settings.render_resolution.y)
			// Rejecting the sample if it's outside of the viewport
			return -1;

		neighbor_pixel_index = neighbor_pixel_coords.x + neighbor_pixel_coords.y * render_data.render_settings.render_resolution.x;
		if (render_data.render_settings.enable_adaptive_sampling && render_data.render_settings.sample_number >= render_data.render_settings.adaptive_sampling_min_samples)
		{
			// If adaptive sampling is enabled, we only want to reuse a converged neighbor if the user allowed it
			// We also check whether or not we've reached the minimum amount of samples of adaptive sampling because
			// if adaptive sampling hasn't kicked in yet, there's no need to check whether the neighbor has converged or not yet

			if (spatial_pass_settings.allow_converged_neighbors_reuse)
			{
				// If we're allowing the reuse of converged neighbors, only doing so with a certain probability

				if (rng_converged_neighbor_reuse() > spatial_pass_settings.converged_neighbor_reuse_probability)
				{
					// We didn't pass the probability check, we are not allowed to reuse the neighbor if it
					// has converged

					if (render_data.aux_buffers.pixel_converged_sample_count[neighbor_pixel_index] != -1)
						// The neighbor is indeed converged, returning invalid neighbor with -1
						return -1;
				}
			}
			else if (render_data.aux_buffers.pixel_converged_sample_count[neighbor_pixel_index] != -1)
				// The user doesn't allow reusing converged neighbors and the neighbor is indeed converged
				// Returning -1 for invalid neighbor
				return -1;
		}
	}

	return neighbor_pixel_index;
}

/**
 * Counts how many neighbors are eligible for reuse.
 * This is needed for proper normalization by pairwise MIS weights.
 *
 * A neighbor is not eligible if it is outside of the viewport or if
 * it doesn't satisfy the normal/plane/roughness heuristics
 *
 * 'out_valid_neighbor_M_sum' is the sum of the M values (confidences) of the
 * valid neighbors. Used by confidence-weights pairwise MIS weights
 *
 * The bits of 'out_neighbor_heuristics_cache' are 1 or 0 depending on whether or not
 * the corresponding neighbor was valid or not (can be reused later to avoid having to
 * re-evauate the heuristics). Neighbor 0 is LSB.
 */
template <bool IsReSTIRGI>
HIPRT_HOST_DEVICE HIPRT_INLINE void count_valid_spatial_neighbors(const HIPRTRenderData& render_data,
	const ReSTIRSurface& center_pixel_surface,
	int2 center_pixel_coords, float2 cos_sin_theta_rotation,
	int& out_valid_neighbor_count, int& out_valid_neighbor_M_sum, int& out_neighbor_heuristics_cache)
{
	const ReSTIRCommonSpatialPassSettings& spatial_pass_settings = ReSTIRSettingsHelper::get_restir_spatial_pass_settings<IsReSTIRGI>(render_data);

	int center_pixel_index = center_pixel_coords.x + center_pixel_coords.y * render_data.render_settings.render_resolution.x;
	int reused_neighbors_count = spatial_pass_settings.reuse_neighbor_count;

	out_valid_neighbor_count = 0;
	for (int neighbor_index = 0; neighbor_index < reused_neighbors_count; neighbor_index++)
	{
		int neighbor_pixel_index = get_spatial_neighbor_pixel_index<IsReSTIRGI>(render_data, neighbor_index, center_pixel_coords, cos_sin_theta_rotation, Xorshift32Generator(render_data.random_seed));
		if (neighbor_pixel_index == -1)
			// Neighbor out of the viewport / invalid
			continue;

		if (!check_neighbor_similarity_heuristics<IsReSTIRGI>(render_data, 
			neighbor_pixel_index, center_pixel_index, center_pixel_surface.shading_point, center_pixel_surface.shading_normal))
			continue;

		out_valid_neighbor_M_sum += ReSTIRSettingsHelper::get_restir_spatial_pass_input_reservoir_M<IsReSTIRGI>(render_data, neighbor_pixel_index);
		out_valid_neighbor_count++;
		out_neighbor_heuristics_cache |= (1 << neighbor_index);
	}
}

#endif
